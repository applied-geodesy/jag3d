/***********************************************************************
* Copyright by Michael Loesler, https://software.applied-geodesy.org   *
*                                                                      *
* This program is free software; you can redistribute it and/or modify *
* it under the terms of the GNU General Public License as published by *
* the Free Software Foundation; either version 3 of the License, or    *
* at your option any later version.                                    *
*                                                                      *
* This program is distributed in the hope that it will be useful,      *
* but WITHOUT ANY WARRANTY; without even the implied warranty of       *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
* GNU General Public License for more details.                         *
*                                                                      *
* You should have received a copy of the GNU General Public License    *
* along with this program; if not, see <http://www.gnu.org/licenses/>  *
* or write to the                                                      *
* Free Software Foundation, Inc.,                                      *
* 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.            *
*                                                                      *
***********************************************************************/

package org.applied_geodesy.adjustment.network.observation;

import org.applied_geodesy.adjustment.MathExtension;
import org.applied_geodesy.adjustment.network.ObservationType;
import org.applied_geodesy.adjustment.network.observation.reduction.ProjectionType;
import org.applied_geodesy.adjustment.network.observation.reduction.Reduction;
import org.applied_geodesy.adjustment.network.observation.reduction.ReductionTaskType;
import org.applied_geodesy.adjustment.network.parameter.AdditionalUnknownParameter;
import org.applied_geodesy.adjustment.network.parameter.Orientation;
import org.applied_geodesy.adjustment.network.point.Point;

public class Direction extends Observation {
	private FaceType face = FaceType.ONE;
	private Orientation orientation = new Orientation(true);
	
	public Direction(int id, Point startPoint, Point endPoint, double startPointHeight, double endPointHeight, double measuringElement, double sigma, double distanceForUncertaintyModel) {
		super(id, startPoint, endPoint, startPointHeight, endPointHeight, measuringElement, sigma, distanceForUncertaintyModel);
	}

	@Override
	public double diffXs() {
		double xs = this.getStartPoint().getX();
		double ys = this.getStartPoint().getY();
		double zs = this.getStartPoint().getZ();
		
		double xe = this.getEndPoint().getX();
		double ye = this.getEndPoint().getY();
		double ze = this.getEndPoint().getZ();
		
		double th = this.getEndPointHeight();
		
		double rxs = this.getStartPoint().getVerticalDeflectionX().getValue();
		double rys = this.getStartPoint().getVerticalDeflectionY().getValue();
		
		double rxe = this.getEndPoint().getVerticalDeflectionX().getValue();
		double rye = this.getEndPoint().getVerticalDeflectionY().getValue();
		
		double srxs = Math.sin(rxs);
		double srys = Math.sin(rys);
		double crxs = Math.cos(rxs);
		double crys = Math.cos(rys);
		
		double crxe = Math.cos(rxe);
		double crye = Math.cos(rye);
		double srye = Math.sin(rye);
		double srxe = Math.sin(rxe);
		
		double u = crys*(xe - xs) + srys*(ze - zs) - th*Math.sin(rye - rys)*crxe;
		double v = crxs*(ye - ys) - th*(crxe*crye*crys*srxs - crxs*srxe + crxe*srxs*srye*srys) - crys*srxs*(ze - zs) + srxs*srys*(xe - xs);

		double distSqr2D = u*u + v*v;

		if (distSqr2D == 0.0)
			return 0.0;
		return (crxs*(crys*ye - crys*ys + crys*srxe*th) - srxs*(ze - zs + crxe*crye*th))/distSqr2D;
	}

	@Override
	public double diffYs() {
		double xs = this.getStartPoint().getX();
		double ys = this.getStartPoint().getY();
		double zs = this.getStartPoint().getZ();
		
		double xe = this.getEndPoint().getX();
		double ye = this.getEndPoint().getY();
		double ze = this.getEndPoint().getZ();
		
		double th = this.getEndPointHeight();
		
		double rxs = this.getStartPoint().getVerticalDeflectionX().getValue();
		double rys = this.getStartPoint().getVerticalDeflectionY().getValue();
		
		double rxe = this.getEndPoint().getVerticalDeflectionX().getValue();
		double rye = this.getEndPoint().getVerticalDeflectionY().getValue();
		
		double srxs = Math.sin(rxs);
		double srys = Math.sin(rys);
		double crxs = Math.cos(rxs);
		double crys = Math.cos(rys);
		
		double crxe = Math.cos(rxe);
		double crye = Math.cos(rye);
		double srye = Math.sin(rye);
		double srxe = Math.sin(rxe);
		
		double u = crys*(xe - xs) + srys*(ze - zs) - th*Math.sin(rye - rys)*crxe;
		double v = crxs*(ye - ys) - th*(crxe*crye*crys*srxs - crxs*srxe + crxe*srxs*srye*srys) - crys*srxs*(ze - zs) + srxs*srys*(xe - xs);

		double distSqr2D = u*u + v*v;

		if (distSqr2D == 0.0)
			return 0.0;
		return -(u*crxs)/distSqr2D;
	}

	@Override
	public double diffZs() {
		double xs = this.getStartPoint().getX();
		double ys = this.getStartPoint().getY();
		double zs = this.getStartPoint().getZ();
		
		double xe = this.getEndPoint().getX();
		double ye = this.getEndPoint().getY();
		double ze = this.getEndPoint().getZ();
		
		double th = this.getEndPointHeight();
		
		double rxs = this.getStartPoint().getVerticalDeflectionX().getValue();
		double rys = this.getStartPoint().getVerticalDeflectionY().getValue();
		
		double rxe = this.getEndPoint().getVerticalDeflectionX().getValue();
		double rye = this.getEndPoint().getVerticalDeflectionY().getValue();
		
		double srxs = Math.sin(rxs);
		double srys = Math.sin(rys);
		double crxs = Math.cos(rxs);
		double crys = Math.cos(rys);
		
		double crxe = Math.cos(rxe);
		double crye = Math.cos(rye);
		double srye = Math.sin(rye);
		double srxe = Math.sin(rxe);
		
		double u = crys*(xe - xs) + srys*(ze - zs) - th*Math.sin(rye - rys)*crxe;
		double v = crxs*(ye - ys) - th*(crxe*crye*crys*srxs - crxs*srxe + crxe*srxs*srye*srys) - crys*srxs*(ze - zs) + srxs*srys*(xe - xs);

		double distSqr2D = u*u + v*v;

		if (distSqr2D == 0.0)
			return 0.0;
		return (crxs*(srys*(ye - ys) + srxe*srys*th) - srxs*(xs - xe + crxe*srye*th))/distSqr2D;
	}
	
	@Override
	public double diffVerticalDeflectionXs() {
		double xs = this.getStartPoint().getX();
		double ys = this.getStartPoint().getY();
		double zs = this.getStartPoint().getZ();
		
		double xe = this.getEndPoint().getX();
		double ye = this.getEndPoint().getY();
		double ze = this.getEndPoint().getZ();
		
		double ih = this.getStartPointHeight();
		double th = this.getEndPointHeight();
		
		double rxs = this.getStartPoint().getVerticalDeflectionX().getValue();
		double rys = this.getStartPoint().getVerticalDeflectionY().getValue();
		
		double rxe = this.getEndPoint().getVerticalDeflectionX().getValue();
		double rye = this.getEndPoint().getVerticalDeflectionY().getValue();
		
		double srxs = Math.sin(rxs);
		double srys = Math.sin(rys);
		double crxs = Math.cos(rxs);
		double crys = Math.cos(rys);
		
		double crxe = Math.cos(rxe);
		double crye = Math.cos(rye);
		double srye = Math.sin(rye);
		double srxe = Math.sin(rxe);
		
		double u = crys*(xe - xs) + srys*(ze - zs) - th*Math.sin(rye - rys)*crxe;
		double v = crxs*(ye - ys) - th*(crxe*crye*crys*srxs - crxs*srxe + crxe*srxs*srye*srys) - crys*srxs*(ze - zs) + srxs*srys*(xe - xs);
		double w = th*(srxe*srxs + crxe*crxs*crye*crys + crxe*crxs*srye*srys) - ih + srxs*(ye - ys) + crxs*crys*(ze - zs) - crxs*srys*(xe - xs);
		
		double distSqr2D = u*u + v*v;

		if (distSqr2D == 0.0)
			return 0.0;
		return -(w + ih)*u/distSqr2D; 
	}
	
	@Override
	public double diffVerticalDeflectionYs() {
		double xs = this.getStartPoint().getX();
		double ys = this.getStartPoint().getY();
		double zs = this.getStartPoint().getZ();
		
		double xe = this.getEndPoint().getX();
		double ye = this.getEndPoint().getY();
		double ze = this.getEndPoint().getZ();

		double th = this.getEndPointHeight();
		
		double rxs = this.getStartPoint().getVerticalDeflectionX().getValue();
		double rys = this.getStartPoint().getVerticalDeflectionY().getValue();
		
		double rxe = this.getEndPoint().getVerticalDeflectionX().getValue();
		double rye = this.getEndPoint().getVerticalDeflectionY().getValue();
		
		double srxs = Math.sin(rxs);
		double srys = Math.sin(rys);
		double crxs = Math.cos(rxs);
		double crys = Math.cos(rys);
		
		double crxe = Math.cos(rxe);
		double crye = Math.cos(rye);
		double srye = Math.sin(rye);
		double srxe = Math.sin(rxe);
		
		double u = crys*(xe - xs) + srys*(ze - zs) - th*Math.sin(rye - rys)*crxe;
		double v = crxs*(ye - ys) - th*(crxe*crye*crys*srxs - crxs*srxe + crxe*srxs*srye*srys) - crys*srxs*(ze - zs) + srxs*srys*(xe - xs);

		double distSqr2D = u*u + v*v;

		if (distSqr2D == 0.0)
			return 0.0;
		return (srxs*u*u - v*(crys*(ze - zs) - srys*(xe - xs)) - th*v*Math.cos(rye - rys)*crxe)/distSqr2D;
	}
	
	@Override
	public double diffVerticalDeflectionXe() {
		double xs = this.getStartPoint().getX();
		double ys = this.getStartPoint().getY();
		double zs = this.getStartPoint().getZ();
		
		double xe = this.getEndPoint().getX();
		double ye = this.getEndPoint().getY();
		double ze = this.getEndPoint().getZ();

		double th = this.getEndPointHeight();
		
		double rxs = this.getStartPoint().getVerticalDeflectionX().getValue();
		double rys = this.getStartPoint().getVerticalDeflectionY().getValue();
		
		double rxe = this.getEndPoint().getVerticalDeflectionX().getValue();
		double rye = this.getEndPoint().getVerticalDeflectionY().getValue();
		
		double srxs = Math.sin(rxs);
		double srys = Math.sin(rys);
		double crxs = Math.cos(rxs);
		double crys = Math.cos(rys);
		
		double crxe = Math.cos(rxe);
		double crye = Math.cos(rye);
		double srye = Math.sin(rye);
		double srxe = Math.sin(rxe);
		
		double u = crys*(xe - xs) + srys*(ze - zs) - th*Math.sin(rye - rys)*crxe;
		double v = crxs*(ye - ys) - th*(crxe*crye*crys*srxs - crxs*srxe + crxe*srxs*srye*srys) - crys*srxs*(ze - zs) + srxs*srys*(xe - xs);

		double distSqr2D = u*u + v*v;

		if (distSqr2D == 0.0)
			return 0.0;
		return (th*(u*(crxe*crxs + crye*crys*srxe*srxs + srxe*srxs*srye*srys) - v*Math.sin(rye - rys)*srxe))/distSqr2D;
	}
	
	@Override
	public double diffVerticalDeflectionYe() {
		double xs = this.getStartPoint().getX();
		double ys = this.getStartPoint().getY();
		double zs = this.getStartPoint().getZ();
		
		double xe = this.getEndPoint().getX();
		double ye = this.getEndPoint().getY();
		double ze = this.getEndPoint().getZ();

		double th = this.getEndPointHeight();
		
		double rxs = this.getStartPoint().getVerticalDeflectionX().getValue();
		double rys = this.getStartPoint().getVerticalDeflectionY().getValue();
		
		double rxe = this.getEndPoint().getVerticalDeflectionX().getValue();
		double rye = this.getEndPoint().getVerticalDeflectionY().getValue();
		
		double srxs = Math.sin(rxs);
		double srys = Math.sin(rys);
		double crxs = Math.cos(rxs);
		double crys = Math.cos(rys);
		
		double crxe = Math.cos(rxe);
		double crye = Math.cos(rye);
		double srye = Math.sin(rye);
		double srxe = Math.sin(rxe);
		
		double u = crys*(xe - xs) + srys*(ze - zs) - th*Math.sin(rye - rys)*crxe;
		double v = crxs*(ye - ys) - th*(crxe*crye*crys*srxs - crxs*srxe + crxe*srxs*srye*srys) - crys*srxs*(ze - zs) + srxs*srys*(xe - xs);

		double distSqr2D = u*u + v*v;

		if (distSqr2D == 0.0)
			return 0.0;
		return th*crxe*(v*Math.cos(rye - rys) + u*Math.sin(rye - rys)*srxs)/distSqr2D;
	}
	
	@Override
	public double diffOri() {
		return -1.0;
	}

	public FaceType getFace() {
		return this.face;
	}

	public void setFace(FaceType face) {
		this.face = face;
	}

	@Override
	public double getCorrection() {
		Reduction reductions = this.getReductions();
		
		double calDir = this.getValueAposteriori();
	    double obsDir = this.getValueApriori();

	    // Richtungsreduktion
		if (reductions.getProjectionType() != ProjectionType.NONE && reductions.applyReductionTask(ReductionTaskType.DIRECTION)) {
			double R = reductions.getEarthRadius();
	    	double scale = reductions.getProjectionType() == ProjectionType.UTM ? 0.9996 : 1.0;
	    	double yS = this.getStartPoint().getY();
	    	double xS = this.getStartPoint().getX();
	    	double yE = this.getEndPoint().getY();
	    	double xE = this.getEndPoint().getX();
	    	
	    	// Prüfe Rechtswert der Koordinaten
	    	if (yS >= 1100000 && yS <= 59800000 && yE >= 1100000 && yE <= 59800000) {
	    		// Reduziere Rechtswert
	    		yS = ((yS/1000000.0)%1)*1000000.0-500000.0;
	    		yE = ((yE/1000000.0)%1)*1000000.0-500000.0;
	    		
	    		double k = -(xE - xS) * (2.0*yS + yE)/(6.0*R*R*scale*scale);
	    		obsDir = MathExtension.MOD(obsDir + k, 2.0*Math.PI);
	    	}
	    }
	    
	    double diffDir = obsDir - calDir;
	    
	    // Pruefung ist fuer RiWis, die Fast 0 bzw. 400 gon sind, um eine kleine Verbesserung zu bekommen.
	    if (2.0*Math.PI-Math.abs(diffDir)<Math.abs(diffDir))
	    	if (calDir < obsDir)
	    		calDir += 2.0*Math.PI;
	    	else
	    		calDir -= 2.0*Math.PI;

	    return obsDir - calDir;
	}

	@Override
	public double getValueAposteriori() {
		double xs = this.getStartPoint().getX();
		double ys = this.getStartPoint().getY();
		double zs = this.getStartPoint().getZ();
		
		double xe = this.getEndPoint().getX();
		double ye = this.getEndPoint().getY();
		double ze = this.getEndPoint().getZ();

		double th = this.getEndPointHeight();
		
		double rxs = this.getStartPoint().getVerticalDeflectionX().getValue();
		double rys = this.getStartPoint().getVerticalDeflectionY().getValue();
		
		double rxe = this.getEndPoint().getVerticalDeflectionX().getValue();
		double rye = this.getEndPoint().getVerticalDeflectionY().getValue();
		
		double srxs = Math.sin(rxs);
		double srys = Math.sin(rys);
		double crxs = Math.cos(rxs);
		double crys = Math.cos(rys);
		
		double crxe = Math.cos(rxe);
		double crye = Math.cos(rye);
		double srye = Math.sin(rye);
		double srxe = Math.sin(rxe);
		
		double u = crys*(xe - xs) + srys*(ze - zs) - th*Math.sin(rye - rys)*crxe;
		double v = crxs*(ye - ys) - th*(crxe*crye*crys*srxs - crxs*srxe + crxe*srxs*srye*srys) - crys*srxs*(ze - zs) + srxs*srys*(xe - xs);

		double ori = this.orientation.getValue();

		return MathExtension.MOD(Math.atan2(v, u) - ori, 2.0*Math.PI);
	}

	public void setOrientation(Orientation newOrientation) {
		this.orientation = newOrientation;
		this.orientation.setObservation( this );
	}

	public AdditionalUnknownParameter getOrientation() {
		return this.orientation;
	}
	
	@Override
	public int getColInJacobiMatrixFromOrientation() {
		return this.orientation.getColInJacobiMatrix();
	}

	@Override
	public ObservationType getObservationType() {
		return ObservationType.DIRECTION;
	}
}
